##  初始Linux Shell ##
<b>Linux可划分为四个部分</b>
+ Linux内核
+ GNU工具组件
+ 图形化桌面环境
+ 应用软件

图为Linux系统
![](https://s2.ax1x.com/2019/05/19/EjCovt.md.png)

<b>探究Linux内核</b>
Linux系统的核心是内核,内核控制着计算机系统上的所有硬件和软件：必要时分配硬件，有需要时执行软件。

Linux内核之父是：Linus
+ Linus在赫尔辛基大学上学时就开放了第一版Linux内核

Linux内核基本负责以下四项功能：
+ 系统内存管理
+ 软件程序管理
+ 硬件设备管理
+ 文件系统管理

<b>系统内存管理</b>
操作系统内核的基本功能之一是内存管理，内核不仅管理服务器上的可用物理内存，还可以创建和管理虚拟内存(即并不真实存在的内存)。内核通过硬盘上的存储空间来实现虚拟内存，这块区域称为交互空间(swap space)。内核不断地在交换空间和实际物理内存之间反复交换虚拟内存和存储单元中的内容。这使得系统以为它比物理内存更多的可用内存。

内存存储单元会被按组分为很多块，这些块称作页面(page)。内核会将每个内存页面放在物理内存或交换空间。然后，内核维护一个内存页面表，来指明那些页面位于物理内存内，那些页面被换到磁盘上。
内核会记录那些内存页面正在使用中，并自动把一段时间末访问的内存页面复制到交换空间区域(称之为换出，swpping out)---即使还有可用内存。当程序要访问一个已被换出的内存页面时，内核必须从物理内存换出另外一个内存页面来给它让出空间，然后从交换空间换入(swapping in)请求的内存页面。显然，这个过程要花费时间，并使得运行中的进程变慢。只要Linux系统正在运行，为运行中的程序换出内存页面的过程就不会停歇。

图为Linux系统内存映射
![](https://s2.ax1x.com/2019/05/19/Eji8mV.png)

在/proc/meminfo文件观察Linux系统上虚拟内存的当前状态。下面是/proc/meminfo文件的一个样例
![](https://s2.ax1x.com/2019/05/19/EjFWUU.png)

1、MemTotal：内存总数 (运行内存)
+  系统从加电开始到引导完成，BIOS等要保留一些内存，内核要保留一些内存，最后剩下可供系统支配的内存就是MemTotal。这个值在系统运行期间一般是固定不变的。

2、MemFree：空闲内存数 (系统尚未使用的运行内存)
+   表示系统尚未使用的内存。MemUsed=MemTotal-MemFree就是已被用掉的内存。


3、MemAvailable：可用内存数
  + 应用程序可用内存数。系统中有些内存虽然已被使用但是可以回收的，比如cache/buffer、slab都有一部分可以回收，所以MemFree不能代表全部可用的内存，这部分可回收的内存加上MemFree才是系统可用的内存，即：MemAvailable≈MemFree+Buffers+Cached，它是内核使用特定的算法计算出来的，是一个估计值。它与MemFree的关键区别点在于，MemFree是说的系统层面，MemAvailable是说的应用程序层面。


4、Buffer：缓冲区内存数
5、Cache：缓存区内存数
6、Shared：多个进程共享的内存空间,不常用，暂不讨论。
7、SwapTotal(交换空间的内存(虚拟内存,虚拟出2G的内存) )

注意：默认情况下，运行在Linux系统上的每个进程都有各自的内存页面。进程不能访问其他进程正在使用的内存页面。内核维护着自己的内存区域，出于安全考虑，用户进程不能访问内核进程使用的内存。

输入ipcs -m可以查看创建的共享内存页面
![](https://s2.ax1x.com/2019/05/24/VFkkLT.png)

1、第一列是进程读取资源时所用的参数
2、第二列进程唯一ID值
3、第三列用户组
4、第四列权限
5、第五列字节数量
6、第六列中列出连接在关联的共享内存段的进程数.
7、第七列中列出当前共享内存的状态,当该段内存的mode字段设置了SHM_DEST位时就会显示"dest"字样

参考文章：[ipcs调试](https://blog.csdn.net/macky0668/article/details/6839559)

<b>软件查询管理</b>
Linux操作系统运行中的程序为进程。进程可以在前台运行，将输出的结果显示在屏幕上，也可以在后台运行，隐藏到幕后。内核控制着Linux系统如何管理运行在系统上的所有进程

内核创建了第一个进程(init进程)来启动系统上所有其他的进程。当内核启动时，它会将init进程加载到虚拟内存中。内核在启动任何其他进程时，都会在虚拟内存中给新进程分配一块专用的区域来存储该进程用到的数据和代码。

Linux使用一个表来管理在系统开机时要自动启动的进程，在Linux系统上这个表通常位于/etc/inittab
一些其他版本的Linux系统在/etc/rcX.d (X代码运行级)比如说：Debain,Ubuntu

Linux操作系统的init系统采用了运行级，运行级决定了init进程运行/etc/inittab文件或/etc/rcX.d的目录

Linux级别：
```
Linux系统有7个运行级别(runlevel)
运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动
运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆
运行级别2：多用户状态(没有NFS)
运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式
运行级别4：系统未使用，保留
运行级别5：X11控制台，登陆后进入图形GUI模式
运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动
```

目录说明：
```
/etc/inittab---启动级别
/etc/rcX.d---开机自启服务序列
```

执行sudo runlevel可以看到系统运行级别
![](https://s2.ax1x.com/2019/05/24/VFVs0K.md.png)

设置系统运行级别在/etc/inittab文件下设置

linux系统启动时运行指定程序：[linux添加开机自启动脚本示例详解](https://blog.csdn.net/fireroll/article/details/15503463)

使用ps -aux 可以看到当前所有运行在Linux系统上的进程
![](https://s2.ax1x.com/2019/05/24/VFVbtg.png)

1、第一列显示了进程号(进程号：PID，init进程系统分配给他的是1)
2、第二列显示了进程的当前状态
```
S为睡眠，SW为在睡眠和等待，R代码正在运行，D 无法中断的休眠状态（通常 IO 的进程）； 
R //正在运行可中在队列中可过行的； 
S //处于休眠状态； 
T //停止或被追踪； 
W //进入内存交换 （从内核2.6开始无效）； 
X //死掉的进程 （基本很少见）； 
Z //僵尸进程； 
< //优先级高的进程 
N //优先级较低的进程 
L //有些页被锁进内存； 
s //进程的领导者（在它之下有子进程）； 
l //多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）； 
+位于后台的进程组；)
```
3、该进程被触发启动的时间
4、第四列显示了该CPU运行的使用时间
5、运行的服务名称，一些服务名称在[ ]里面的，是由于没有活动被换出到磁盘交互空间

<b>硬件设备管理</b>
内核的另一职责是管理硬件设备。任何Linux系统需要与通信的设备，都需要在内核代码中加入驱动程序代码。驱动程序代码相当于应用程序和硬件设备的中间人，需要内核同设备之间交换数据，在Linux内核中插入设备驱动代码
+ 编译进内核的设备驱动代码
+ 可插入内核的设备驱动模块

历史：
```
以前插入设备驱动代码唯一的办法就是重新编译内核，每次给系统添加新设备的。
你都要重新编译一遍内核代码，随着Linux内核支持越来越多的硬件设备。这个过程
也越来越低效，不过好在Linux开发人员开发出一种更好的将驱动代码插入到内核的
方法
```

内核模块：
```
开发人员提出了内核模块的概念，它允许将驱动代码插入到运行中的内核而无需重新编译
内核。同时设备不需要使用的时候可以将模块从内核中移走
```

Linux系统将硬件设备当成特殊的文件,称为设备文件
+ 字符型设备文件
+ 块设备文件
+ 网络设备文件

字符型设备文件是指处理数据时每次只能处理一个字符的设备。大多数类型的调制器和终端都是作为字符型设备文件创建的 (读卡器)

块设备文件是指处理数据时每次能处理大块数据的设备 (类似于U盘，移动硬盘)

网络设备文件是指采用数据包发送和接收数据的设备，包括各种网卡和一个特殊的回环设备。这个回环设备允许Linux系统使用通用的网络编程协议同自己通信 (网线，网卡)

执行cd /dev&&ls -al sda* ttyS* 可以看到一些设备文件
![](https://s2.ax1x.com/2019/05/24/VFuxTP.png)

注意：不同的Linux发行版在处理设备时采用不同的设备名
```
sda*=硬件设备
ttyS*=IBM COM端口
```

第二列为状态
第三列为设备号，sda* 的设备号默认是8号，ttS* 的设备号默认是4或6号

<b>文件管理系统</b>
不同于其他的一些操作系统，Linux内核支持多种不同类型的文件系统来从硬盘中读取或写入数据。除了自有的诸多文件系统外，Linux还支持从其他操作系统所采用的文件系统读取或写入数据。内核必须在编译时就加入对所有可能用到的文件系统的支持

Linux文件系统：
```
ext Linux扩展文件系统
ext2 第二扩展文件系统，在ext的基础上提供了更多功能
ext3 第三扩展系统，支持日志功能
ext4 第四扩展文件系统，支持高级日志功能
hpfs OS/2高性能文件系统
jfs IBM日志文件系统
iso9660 ISO 9660文件系统(CD-ROM)
minix MINIX文件系统
msdos 微软的FAT16
ncp Netware文件系统
nfs 网络文件系统
ntfs 支持Microsoft NT文件系统
proc 访问系统信息
ReiserFS 高级Linux文件系统，能提供更好的性能和硬盘恢复功能
smb 较早期的samba SMB文件系统
sysv 较高期的Unix文件系统
ufs BSD文件系统
umsdos 存在msdos上的类unix文件系统
vfat windows 95文件系统（FAT32）
xfs 高性能64位日志文件系统
```
任何Linux服务器访问的硬盘都必须格式化表所列的文件系统类型一种
Linux内核采用虚拟文件系统（VFS）作为和每个文件系统交互的接口。这为Linux内核同任何类型文件系统通信提供了一个标准接口。当每个文件系统被挂载和使用时，VFS将信息都缓存在内存中

<b>GNU工具链</b>
除了由内核来控制硬件设备外，操作系统还需要工具链来执行一些标准功能。比如控制文件和程序

GNU项目一开始主要是为Unix系统管理员设计的，用以提供一个类似Unix环境。这个目标导致这个项目移植了很多Unix系统通用的命令行工具。为Linux系统提供的一组核心工具被称为coreutils软件包

GNU coreutils软件包由3部分构成：
+ 用以处理文件的工具
+ 用以操作文本的工具
+ 用以管理进程的工具
这三组主要工具中的每一组都包含一些对Linux系统管理员和程序员重要的工具

shell：GNU/Linux shell是个交互式工具，它为用户提供了启动程序、管理文件系统上的文件以及管理运行在Linux系统进程的途径，shell的核心是命令行提示符，命令行提示符是shell的交互部分。它允许你输入文本命令，之后解释命令并在内核中执行

Linux常用的几种shell：
```
ash 运行在内存受限中简单的，轻量级级shell，但与bash shell完全兼容
korn 与Bourne shell兼容编程的shell，但支持一些高级的编程特性
tcsh 将C语言的一些元素引入到shell脚本
zsh 将bash，tcsh和korn的特性引入，同时提供高级编程特性，共享历史文件和主题化提示符的高级shell
```
大多数Linux发行版包含多个shell，虽然它们通常会采用其中一个作为默认shell

<b>Linux桌面环境</b>
早在20世纪90年代，系统上可用的仅仅是一个文本界面与操作系统交互。到后来windows的普及，用户期望的就不仅仅是对着文本界面与系统交互。希望Linux也能有桌面

X Window系统：
有两项基本组件能决定的桌面环境：显卡和显示器，要在电脑上显示绚丽的画面，Linux软件就得知道如何来连接他们，X Window软件是图形显示的核心元素

Linux的桌面环境：
```
KDE 类似于windows的图形化界面
GNOME 网络镜像环境
fluxbox 一个没有面板的轻型桌面
xfce 和KDE很像但少了很多图形以适应低内存
jWM 超微型桌面
fvwm 支持虚拟桌面和高级桌面功能，但在低内存环境运行
fvwm95 从fvwm衍生而来，像windows 95的桌面
```

查看自己的桌面环境执行echo $DESKTOP_SESSION
![](https://s2.ax1x.com/2019/05/24/VFN9QP.png)

<b>Linux发行版</b>
我们将完整的Linux系统包称为发行版。各种不同的Linux发行版来满足可能存在的各种运算需求

不同的Linux发行版通常归类为三类：
+ 完整的核心Linux发行版
+ 核心Linux发行版
+ LiveCD测试发行版

常见的Linux发行版：
```
Ubuntu
Debain
Manjaro
.............
```
LiveCD测试发行版：
不需要安装Linux系统，将LiveCD包写入到U盘。插入即可使用系统，但是有一定的缺点
如：
+ 不能存数据
+ 不能保存用户执行的操作
+ 不能移动文件

到后面LiveCD改进了，支持以上的操作

