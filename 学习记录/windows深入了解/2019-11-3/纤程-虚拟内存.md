# 线程
线程是一个进程内部的实体，㛑是Windows执行此进程时的调度实体。如果没有线程，进程的程序将不可能运行。线程包括以下一些最基本的部件：
* 一组代表处理器状态的CPU寄存器中的内容
* 两个栈——一个用于在线程内核模式下执行时，另一个用于线程在用户模式下执行时
* 一个被称为线程局部存储的私有存储区域，各个子系统、运行库和DLL都会用到该存储区域
* 有时候线程也有它们自己的安全环境，或者令牌，多线程服务器应用程序要模仿其客户的安全环境时，常常会使用线程自己的安全环境

易失的寄存器、栈和私有存储区域合起来被称为线程的环境。因为这些信息随着Windows所在机器架构的不同而由所不同，所以，此结果必须是与底层架构相关的。Windows的GetThreadContext函数允许程序访问这一与架构相关的信息（称为CONTEXT块）
```
对于在64位windows版本运行的32位应用程序，其线程将同时包含32位和64位环境，Wow64会在必要的
时候利用此环境，将应用程序从32位切换到64位模式下。这些线程将有两个用户栈和两个CONTEXT块，
常规的Windows API函数返回64位环境。然而，Wow64GetThreadContext函数将返回32位环境
```

# 纤程
纤程使得一个应用程序可以调度它自己的"线程"的执行过程，而不必依赖于Widnows内置的基于优先级的调度机制。纤程也被称为轻量级线程；从调度的角度来看，它们对于内核是不可见的，因为它们是在用户模式下在Kernel32.dll中实现的。为了使用纤程，首先要调用Windows的ConvertThreadToFiber函数。
该函数将当前线程转换成一个正在运行的纤程。纤程不会自动运行，它必须由SwitchToFiber函数手工选中，然后才能执行。新的纤程会一直运行，直到退出，或者钓鱼SwitchToFiber再次选择运行另外一个纤程。


# UMS线程
UMS线程仅在64位的Windows上可用，它基本上提供了与纤程通用的好处，UMS线程有它们自己的内核线程状态，因此对于内核是可见的，这使得多个UMS线程都可以发出阻塞系统调用、对源进行共享或竞争，并且每个线程特有的状态。


![006LG7Nygy1g8ko8x1vf9j30n106j42k.jpg](http://ww1.sinaimg.cn/large/006LG7Nygy1g8ko8x1vf9j30n106j42k.jpg)

虽然线程有自己的执行环境，但是，同一个进程内部的所有线程共享该进程的虚拟地址空间。然而，一个进程的线程不可能无意的引用另一个进程的地址空间。除非两种情况：第二个进程将他的一部分私有地址空间变成共享内存区。（Windows AP称为文件映射对象）；或者第一个进程有权打开第二个进程，从而可以使用如ReadProcessMemory和WriteProcessMemory等跨进程内存函数

除了私有地址空间和一个或多个线程外每个进程还有一个安全环境和一个已打开句柄的列表。这些句柄指向诸如文件、共享内存区、或者像互斥体、事件或信号量等某个同步对象。


![006LG7Nygy1g8kokfssg8j30ia08twgb.jpg](http://ww1.sinaimg.cn/large/006LG7Nygy1g8kokfssg8j30ia08twgb.jpg)

# 进程及其资源
每个进程都有一个安全环境存储在一个称为访问令牌的对象中，进程的访问令牌包含了该进程的安全标识和凭证，在默认情况下线程没有自己的访问令牌，但是他们也可以获得一个访问令牌，因此单独的线程可以模仿另一个进程的安全环境。包括在远程windows系统上运行的进程而不会影响当前进程中的其他线程。

虚拟地址描述符：是指一些数据结构，内存管理器利用这晕倒在进程模型上提供了一个扩展称为作业，作业对象的主要功能是使一个进程被当作一个整体来管理和维护。通过作业对象可以对特定的属性进行控制。也可以使一个进程或者所有与作业相关联的进程进行限制。作业对象也为所有与作业相关联的进程记录下基本的审计信息，其中也包括曾经与该作业关联，但是已经终止了到进程的审计信息在某种程度上。作业对象你补了windows平台上缺乏结构化的进程数的不足。

# 虚拟内存
Windows实现了一个基于平面地址空间的虚拟内存系统。使每个进程感觉自己独立，拥有一个很大的私有地址空间。
转义或者映射成真正放数据的物理地址，操作系统通过控制这一保护和映射机制，可以确保一个进程不会闯入另一个进程中，也不会改写操作系统的数据。
![006LG7Nygy1g8kox6cr0kj30jc07xta3.jpg](http://ww1.sinaimg.cn/large/006LG7Nygy1g8kox6cr0kj30jc07xta3.jpg)

将虚拟内存映射到物理内存：
因为大多数系统拥有的物理内存比当前正在运行的进程所用到的虚拟内存总量要少的多，所以内存管理器会将内存中的有些内容转移或者翻到磁盘上将数据翻到磁盘上以后就可以释放出这部分的物理内存，因此这些物理内存可以被别的进程所用或者用于操作系统自身，当线程访问一个已被翻到磁盘上的虚拟内存地址时，虚拟内存管理器会将磁盘上的信息装回内存中，应用程序无需改变就可以利用这个分页功能，因为在硬件的支持下内存管理器无需任何关于进程和线程的知识，也无需进程和线程的协助，就可以实现分页。


![006LG7Nygy1g8kp3b7vlkj30n90b4agm.jpg](http://ww1.sinaimg.cn/large/006LG7Nygy1g8kp3b7vlkj30n90b4agm.jpg)

![006LG7Nygy1g8kphgfrbqj30ji080gn8.jpg](http://ww1.sinaimg.cn/large/006LG7Nygy1g8kphgfrbqj30ji080gn8.jpg)

![006LG7Nygy1g8kpi20o2wj30nl0g3103.jpg](http://ww1.sinaimg.cn/large/006LG7Nygy1g8kpi20o2wj30nl0g3103.jpg)
32位系统最大虚拟内存：4GB
64位系统最大虚拟机内存：8192GB



